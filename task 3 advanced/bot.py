# -*- coding: utf-8 -*-
"""bot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eE5bxkbqxtvGa57WAExUKX72dM3Njin9
"""

pip install aiogram nltk numpy scipy gensim

# Импортируем необходимые модули
from aiogram import Bot, Dispatcher, types
import asyncio
import json
import os
import requests
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from gensim.models import Word2Vec
import numpy as np
import gensim
from gensim.models import Word2Vec
from sklearn.metrics.pairwise import cosine_similarity

# Токен API бота
api_token = 'my_token'

# Настраиваем логирование, чтобы видеть информацию о работе бота в консоли
logging.basicConfig(level=logging.INFO)

bot = Bot(token=api_token)
# Создаем объект диспетчера, который управляет входящими сообщениями и командами
dp = Dispatcher()

# Загрузка файла faq.json из файла fGitHub
!wget faq.json https://raw.githubusercontent.com/vifirsanova/compling/main/tasks/task3/faq.json

with open("faq.json", "r", encoding="utf-8") as file:
    data = json.load(file)

# Извлечение вопросов и ответов из данных data
faq_questions = []
faq_answers = []
for q in data.values():
    for y in q:
        faq_questions.append(y['question'])
        faq_answers.append(y['answer'])

# TF-IDF преобразование
vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(faq_questions)

# Подгружаем Word2Vec
sentences = [q.split() for q in faq_questions]
model = Word2Vec(sentences, vector_size=100, window=5, min_count=1, workers=4)

# Функция для усреднения векторов слов в вопросе
def sentence_vector(sentence, model):
    words = sentence.split()
    vectors = [model.wv[word] for word in words if word in model.wv]
    return np.mean(vectors, axis=0) # Берем среднее значение по всем векторам, чтобы одно предложение представлял один вектор

# Векторизуем вопросы
faq_vectors = np.array([sentence_vector(q, model) for q in faq_questions])

# Создаем функцию для выбора наиболее подходящего ответа (на основе TF-IDF)
def get_answer_tfidf(question):
    query_vec = vectorizer.transform([question])
    similarities = cosine_similarity(query_vec, tfidf_matrix)
    best_match_idx = similarities.argmax()
    return faq_answers[best_match_idx]

# Создаем функцию для выбора наиболее подходящего ответа на основе Word2Vec
def get_answer_word2vec(question):
    query_vector = sentence_vector(question, model).reshape(1, -1)
    similarities = cosine_similarity(query_vector, faq_vectors)
    best_match_idx = similarities.argmax()
    return faq_answers[best_match_idx]

# Список кнопок
kb = [
    [
        KeyboardButton(text="О компании"),
        KeyboardButton(text="Пожаловаться")
    ]
]

# Запускаем интерфейс с кнопками
keyboard = ReplyKeyboardMarkup(
    keyboard=kb,
    resize_keyboard=True,
    input_field_placeholder="Пожалуйста, выберите запрос"
)

# обрабатываем команду start
@dp.message(Command("start"))
async def start_command(message: types.Message):
    await message.answer("Привет! Это бот, который может ответить на Ваши вопросы.", reply_markup=keyboard)

# Обработка кнопки "О компании" и вывод строки "Наша компания занимается доставкой товаров по всей стране."
@dp.message(lambda message: message.text == "О компании")
async def about_company(message: types.Message):
    await message.answer("Наша компания занимается доставкой товаров по всей стране.")

# Обработка кнопки "Пожаловаться"
@dp.message(lambda message: message.text == "Пожаловаться")
async def complain(message: types.Message):
    await message.answer("Пожалуйста, прикрепите фотографию или скриншот.")

# Обработка фотографии или скриншота
@dp.message(lambda message: message.content_type == "photo")
async def handle_photo(message: types.Message):
    file_id = message.photo[-1].file_id
    file = await bot.get_file(file_id)
    filename = file.file_path.split("/")[-1]
    filesize = message.photo[0].file_size
    await message.answer(f'Ваш запрос передан специалисту. Название файла: {filename}, размер: {filesize} байт')

# Обработка запросов/вопросов от пользователей
@dp.message()
async def answer_question(message: types.Message):
    question = message.text
    answer_tfidf = get_answer_tfidf(question)
    answer_word2vec = get_answer_word2vec(question)
    await message.answer("Ответ TF-IDF: " + answer_tfidf)
    await message.answer("Ответ Word2Vec: " + answer_word2vec)

# Запуск бота
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    await main()